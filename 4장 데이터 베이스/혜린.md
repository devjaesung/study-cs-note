# 4장 데이터베이스

# 4.1 데이터베이스의 기본

- 데이터 베이스 (DB, Database): 일정한 규칙, 혹은 규약을 통해 구조화되어 저장하는 데이터 모음
  - 실시간 접근과 동시 공유 가능
- DBMS (Database Management System): 해당 데이터 베이스를 제어, 관리하는 통합 시스템
  - 데이터베이스의 데이터들은 특정 DBMS마다 정의된 `쿼리 언어 (query language)` 를 통해 삽입, 삭제, 수정, 조회

## 4.1.1 엔터티

- 엔터티(entity): 사람, 장소, 물건, 사건, 개념 등 여러 개의 **속성**을 지닌 **명사**를 의미
- 강한 엔터티 vs 약한 엔터티
  - 강한 엔터티 : 혼자서 존재할 수 있는 엔터티 (ex. 건물)
  - 약한 엔터티 : 다른 엔터티의 존재 여부에 따라 의존적인 엔터티 (ex. 방)

## 4.1.2 릴레이션

- 릴레이션: 데이터 베이스에서 정보를 구분하여 저장하는 기본 단위

  - 관계형 데이터베이스 릴레이션 : `테이블`
  - NoSQL 데이터베이스 릴레이션 : `컬렉션`

- 테이블과 컬렉션
  - 관계형 데이터베이스 (MySQL)
    - 레코드 - 테이블 - 데이터베이스
  - NoSQL 데이터베이스 (MongoDB)
    - 도큐먼트 - 컬렉션 - 데이터베이스

## 4.1.3 속성

- 속성 (attribute): 릴레이션에서 관리하는 구체적이며 고유한 이름을 갖는 정보
  - 서비스의 요구 사항에 맞춰 엔터티의 속성이 정해짐

## 4.1.4 도메인

- 릴레이션에 포함된 각각의 속성들이 가질 수 있는 집합
  - ex) 성별 속성의 도메인 -> {남,여}

## 4.1.5 필드와 레코드

테이블은 필드와 레코드로 구성됨

회원이란 **엔티티**는 member라는 **테이블**로 **속성**인 이름, 아이디 등을 가지고 있음

- `필드` : name, ID, address
- `레코드 (튜플)` : 테이블에 쌓이는 행(row) 단위의 데이터

**필드 타입**

필드는 DBMS마다 다른 각자의 타입을 가짐

1. 숫자 타입

1. 날짜 타입

- **DATE** : 날짜만 사용 (3 bytes)
- **DATETIME** : 날짜 및 시간 모두 사용 (8 bytes)
- **TIMESTAMP** : 날짜 및 시간 모두 사용 (4 bytes)

1. 문자 타입

- **글자 수 지정 타입**
  - **CHAR** : 고정 길이 문자열 (0~255)
  - **VARCHAR** : 가변 길이 문자열 (0~65535)
    - 입력된 데이터에 따라 용량을 가변시켜 저장
    - 해당 바이트 + 길이 기록용 **1 바이트**
- **큰 데이터 저장 타입**
  - **TEXT** : 큰 문자열 저장에 사용
    - 주로 게시판의 본문
  - **BLOB** : 이미지, 동영상 등 큰 데이터 저장
    - but, 보통은 아마존 S3를 이용하고 파일 경로를 VARCHAR로 저장
- **문자열 열거 타입**
  - **ENUM** : ENUM(x-small, small, medium, large, x-large) 형태로 쓰이며 단일 선택만 가능
    - 잘못된 값을 삽입하면 빈 문자열이 대신 삽입
    - x-small 등이 0,1 등으로 매핑되어 메모리를 적게 사용하는 이점
    - 최대 65,535개의 요소
  - **SET** : ENUM과 비슷하지만, 여러 개의 데이터를 선택할 수 있고 비트 단위의 연산을 할 수 있음
    - 최대 64개의 요소

## 4.1.6 관계

데이터베이스에는 여러 개의 테이블이 있고 이러한 테이블은 서로의 관계가 정의되어 있음. 이러한 관계를 관계화살표로 나타냄

1. **1:1 관계**

   - ex) 유저당 유저 이메일은 하나씩 있는 경우

1. **1:N 관계**

   한 개체가 다른 많은 개체를 **포함**하는 관계

   - ex) 한 유저당 어러 개의 상품을 장바구니에 넣는 경우

1. **N:M 관계**

   테이블 두 개를 직접적으로 연결해서 구축하지는 않고 1:N, 1:M 라는 관계를 갖는 테이블 두 개로 나눠서 설정

   - ex) 학생과 강의의 관계

## 4.1.7 키

- 키 (key): 테이블 간의 관계를 조금 더 명확하게 하고, 테이블 자체의 인덱스를 위해 설정된 장치

  - 기본키, 외래키, 후보키, 슈퍼키, 대체키

- 유일성: 중복되는 값이 없음
- 최소성: 필드를 조합하지 않고 최소 필드만 써서 키를 형성할 수 있음

1. **기본키 (PK, primary key)**

   - **유일성**과 **최소성**을 만족하는 키
   - 자연키 또는 인조키 중 설정
     - 자연키: 중복되지 않는 것을 '자연스레' 뽑다가 나오는 키 - 언젠가는 변하는 속성을 가짐
     - 인조키: : 인위적으로 생성한 키 - 변하지 않음 -> 보통 기본키로 사용

1. **외래키 (FK, foreign key)**

   - 다른 테이블의 기본키를 그대로 참조하는 값
   - 개체와의 관계를 식별하는 데 사용
   - 중복되어도 상관 없음

1. **후보키 (candidate key)**
   - 기본키가 될 수 있는 후보들
   - **유일성**과 **최소성**을 동시에 만족하는 키
1. **대체키 (alternate key)**
   - 후보키가 두 개 이상이 경우 기본키 이외의 남은 후보키들
1. **슈퍼키 (super key)**
   - 레코드를 유일하게 식별할 수 있는 **유일성**을 갖춘 키

# 4.2 ERD와 정규화 과정

## 4.2.1 ERD의 중요성

- ERD (Entity Relationship Diagram): 데이터베이스를 구축할 때 가장 기초적인 뼈대 역할을 하며, 릴레이션 간의 관계들을 정의한 것
  - 시스템의 요구 사항을 기반으로 작성됨
  - 디버깅 또는 재설계가 필요한 경우에도 설계도 역할 담당
  - **관계형 구조**로 표현할 수 있는 데이터를 구성하는 데 유용
  - But, **비정형 데이터**는 충분히 표현할 수 없음

❓ 비정형 데이터

비구조화 데이터로, 미리 정의된 데이터 모델이나 정의된 방식이 없는 정보

## 4.2.2 예제로 배우는 ERD

## 4.2.3 정규화 과정

- 정규화 과정

  - 릴레이션 간의 잘못된 종속 관계로 인해 **데이터베이스 이상 현상**이 일어나서 이를 해결하거나, 저장 공간을 효율적으로 사용하기 위해 릴레이션을 **여러 개로 분리**하는 과정
  - **정규형 원칙**을 기반으로 정규형을 만들어가는 과정
  - 정규화된 정도 : **정규형(NF, Normal Form)**으로 표현
    - 기본 정규형 : 제1 정규형, 제2 정규형, 제3 정규형, 보이스/코드 정규형
    - 고급 정규형 : 제4 정규형, 제5 정규형

- 데이터베이스 이상 현상 : 회원이 한 개의 등급을 가져야 하는데 세 개의 등급을 갖거나, 삭제할 때 필요한 데이터가 같이 삭제되고 데이터를 삽입해야 하는데 하나의 필드값이 NULL이 되면 안되어서 삽입하기 어려운 현상

❓ 정규화 과정을 거친다고 성능이 100% 좋아지는 것은 아님

테이블을 나누게 되면 어떠한 쿼리는 조인을 해야 하는 경우도 발생해서 오히려 느려질 수 있음. 따라서 서비스에 따라 정규화 또는 비정규화 과정을 진행해야 함

**정규형 원칙**

- 같은 의미를 표현하는 릴레이션의 경우
  - 좀 더 좋은 구조로 만들어야 함
  - 자료의 중복성은 감소해야 함
  - 독립적인 관계는 별개의 릴레이션으로 표현해야 함
  - 각각의 릴레이션은 독립적인 표현이 가능해야 함

**제 1 정규형**

- 릴레이션의 모든 도메인이 더 이상 분해될 수 없는 **원자 값(atomic value)만으로** 구성되어야 함
- 한 개의 기본키에 대해 두 개 이상의 값을 가지는 반복 집합이 있어서는 안 됨

**제 2 정규형**

- 릴레이션이 제1 정규형이며 **부분 함수의 종속성을 제거한 형태**
- 기본키가 아닌 모든 속성이 기본키에 **완전 함수 종속적**
- 릴레이션 분해시 동등한 릴레이션으로 분해해야 하고, 정보 손실이 발생하지 않는 무손실 분해가 돼야 함

**제 3 정규형**

- 릴레이션이 제2 정규형이고 기본키가 아닌 모든 속성이 **이행적 함수 종속(transitive FD)**을 만족하지 않는 상태

❓이행적 함수 종속 : A->B와 B->C가 존재하면 논리적으로 A->C가 성립하는데, 이때 집합C가 집합A에 이행적으로 함수 종속 되었다고 함.

**보이스/코드 정규형**

- 릴레이션이 제3 정규형이고, 릴레이션의 함수 종속 관계에서 **모든 결정자가 후보키**

인 상태

- 결정자가 후보키가 아닌 함수 종속 관계를 제거함

❓ 결정자: 함수 종속 관계에서 특정 종속자(dependent)를 결정짓는 요소

X->Y 일 때 'X'는 결정자, 'Y'는 종속자

# 4.3 트랜잭션과 무결성

## 4.3.1 트랜잭션

트랜잭션(transaction): 데이터베이스에 하나의 논리적 기능을 수행하기 위한 작업의 단위로, 여러 개의 쿼리들을 하나로 묶는 단위

- ACID 특징을 가짐 - 원자성, 일관성, 독립성, 지속성

1. 원자성

- **"all or nothing" -** 트랜잭션과 관련된 일이 **모두** 수행되었거나 되지 않았거나를 보장하는 특징
- 트랜잭션이 커밋했는데, 문제가 발생하여 롤백하는 경우 그 이후에 모두 수행되지 않음을 보장
- 트랜잭션 단위로 여러 로직들을 묶을 때 외부 API를 호출하는 것이 있으면 안 됨

만약 있다면 롤백 시에 해결법과 트랜잭션 전파를 신경써서 관리해야 함

**커밋과 롤백**

- 커밋

  - 여러 쿼리가 성공적으로 처리되었다고 확정하는 명령어
  - 변경된 내용이 모두 영구적으로 저장됨

- 롤백

  - 트랜잭션으로 처리한 하나의 묶음 과정을 일어나기 전으로 돌리는 일(취소)

- 커밋과 롤백 덕에 **데이터의 무결성** 보장 가능
  - 데이터 변경 전에 변경 사항 쉽게 확인 가능
  - 해당 작업을 그룹화 가능

**트랜잭션 전파**

- 트랜잭션을 수행할 때 커넥션 단위로 수행함.
- 커넥션 객체를 매번 넘겨서 트랜잭션을 수행하는 대신 여러 트랜잭션 관련 메서드의 호출을 하나의 트랜잭션에 묶이도록 하는 것

1. 일관성
   - '허용된 방식'으로만 데이터를 변경해야 하는 것
     - 데이터베이스에 기록된 모든 데이터는 여러 가지 조건, 규칙에 따라 유효함을 가져야 함
     - ex) 잔고 0원으로부터 500만원 송금 불가능
2. 격리성

- 트랜잭션 수행 시 서로 끼어들지 못하는 것
  - 복수의 병렬 트랜잭션은 서로 격리되어 **마치 순차적으로 실행**되는 것처럼 작동돼야 함
  - 데이터베이스는 여러 사용자가 같은 데이터에 접근할 수 있어야 함
  - 격리성은 여러 개의 격리 수준으로 나뉘어 격리성 보장

**격리 수준**

1. **SERIALIZABLE** : 트랜잭션을 순차적으로 진행

   - 여러 트랜잭션이 동시에 같은 행 접근 불가
   - 매우 엄격한 수준
   - 교착상태가 일어날 확률 ⬆️
   - 가장 성능이 떨어짐

1. **REPEATABLE_READ**

   - 하나의 트랜잭션이 수정한 행을 다른 트랜잭션이 수정할 수 없도록 막아줌
   - 다른 트랜잭션이 새로운 행을 추가하는 것은 막지 않음

1. **READ_COMMITTED** : 가장 많이 사용되는 격리 수준

   - 커밋 완료된 데이터에 대해서만 조회를 허용
   - 한 트랜잭션이 접근한 행을 다른 트랜잭션이 수정 가능
   - A가 수정하고 B가 다시 수정한 행을 A가 다시 읽을 때 다른 내용 발견 가능

1. **READ_UNCOMMITTED** : 가장 빠른 격리 수준
   - 가장 낮은 격리 수준
   - 하나의 트랜잭션이 커밋되기 이전에 **다른 트랜잭션에 노출**되는 문제가 있음
   - 거대한 양의 데이터를 '어림잡아' 집계하는 데 사용하면 좋음

**격리 수준에 따라 발생하는 현상**

1.  팬텀 리드 (phantom read) : 한 트랜잭션 내에서 동일한 쿼리를 보냈을 때 해당 조회 결과가 다른 경우
    - 동일한 쿼리에 다른 **행**이 선택될 수도 있음
2.  반복 가능하지 않은 조회 (non-repeatable read) : 한 트랜잭션 내의 같은 행에 두 번 이상 조회 시, 그 값이 다른 경우
    - 동일한 쿼리에 같은 행의 다른 **값**이 선택될 수도 있음
3.  더티 리드 (dirty read) : 한 트랜잭션 실행 중에 아직 **커밋되지 않은 행**의 데이터를 읽을 수 있는 경우

    - 다른 트랜잭션에 의해 **수정**되었지만 **커밋되지 않은** 상태일 수 있음

4.  지속성
    - 성공적으로 수행된 트랜잭션은 영원히 반영되어야 하는 것을 의미
    - DB에 시스템 장애가 발생하도 원래 상태로 복구하는 **회복 기능**이 있어야 함
    - 이를 위해 **체크섬**, **저널링**, **롤백** 등의 기능 제공

❓ 용어

- 체크섬: 중복 검사의 한 형태로, **오류 정정**을 통해 무결성 보호
- 저널링: 변경 사항을 반영(commit)하기 전에 **로깅**하는 것, 트랜잭션 등 변경 사항에 대한 **로그**를 남기는 것

## 4.3.2 무결성

- 무결성: 데이터의 정확성, 일관성, 유효성을 유지하는 것
- 무결성이 유지되어야 DB의 값과 그 값에 해당하는 현실 세계의 값이 일치한다고 신뢰할 수 있음

**무결성의 종류**

| 이름        | 설명                                                                         |
| ----------- | ---------------------------------------------------------------------------- |
| 개체 무결성 | 기본키로 선택된 필드는 **빈 값을 허용하지 않음**                             |
| 참조 무결성 | 서로 참조 관계의 두 테이블의 데이터는 **항상 일관된 값 유지**                |
| 고유 무결성 | 고유한 값을 가지는 조건의 속성의 경우 그 속성 값은 **모두 고유한 값**을 가짐 |
| NULL 무결성 | NULL이 올 수 없다는 조건의 속성의 경우 그 속성 값은 **모두 NULL이 아님**     |

# 4.4 데이터베이스 종류

## 4.4.1 관계형 데이터베이스

- 관계형 데이터베이스: 행과 열을 가지는 표 형식 데이터를 저장하는 형태의 데이터베이스
  - SQL 언어로 조작
  - ex) MySql, PostgreSQL, 오라클, SQL Server, MSSQL
  - 표준 SQL을 지키기는 하지만 각각의 제품에 특화시킨 SQL 사용

1. MySQL
   - 대부분의 운영체제와 호환되며 현재 가장 많이 사용하는 데이터베이스
   - C, C++로 만들어짐
   - MyISAM 인덱스 압축 기술, B-트리 기반의 인덱스, 스레드 기반의 메모리 할당 시스템, 매우 빠른 조인, 최대 64개 인덱스 제공
   - 대용량 데이터베이스를 위해 설계
   - 롤백, 커밋, 이중 암포 지원 보안 등의 기능 제공

MySQL **스토리지 엔진 아키텍처**

- 스토리지 엔진 : 데이터베이스의 심장 역할
- 모듈식 아키텍처로 쉽게 스토리지 엔진을 바꿀 수 있으며, 데이터 웨어 하우징, 트랜잭션 처리, 고가용성 처리에 강점
- 스토리지 엔진 위에 커넥터 API 및 서비스 계층을 통해 MySQL 데이터베이스와 쉽게 상호 작용
- 쿼리 캐시를 지원해 입력된 쿼리 문에 대한 전체 결과 집합을 저장하기 때문에 사용자가 작성한 쿼리가 캐시에 있는 쿼리와 동일하면 서버는 단순히 구문 분석, 최적화 및 실행을 건너뛰고 캐시의 출력만 표시

1. PostgreSQL

MySQL 다음으로 개발자들이 선호하는 데이터베이스 기술

- VACUUM : 디스크 조각이 차지하는 영역을 회수할 수 있음
- 최대 테이블 크기 : 32TB
- SQL 뿐만 아니라 JSON 이용해 데이터에 접근 가능
- 지정 시간 복구 기능, 로킹, 접근 제어, 중첩된 트랜잭션, 백업 등

## 4.4.2 NoSQL 데이터베이스

SQL을 사용하지 않는 데이터베이스

- 전통적인 RDBMS와 다른 DBMS를 지칭하기 위한 용어로 데이터 저장에 고정된 테이블 스키마가 필요하지 않고 조인 연산 사용 불가능
- 수평적으로 확장 가능
- ex) MongoDB, redis 등

1. MongoDB

**JSON**을 통해 데이터 접근 가능하며 **Binary JSON 형태(BSON)**로 데이터가 저장

- 와이어드타이거 엔진이 기본 스토리지 엔진으로 장착된 키-값 데이터 모델에서 확장된 도큐먼트 기반의 데이터베이스
- 확장성과 빅데이터 저장할 때 성능이 좋다
- 고가용성, 샤딩, 레플리카셋 지원
- 스키마를 정해 놓지 않고 데이터를 삽입할 수 있어 다양한 도메인의 데이터베이스를 기반으로 분석하거나 로깅 등을 구현할 때 강점
- 도큐먼트를 생성할 때마다 다른 컬렉션에서 중복된 값을 지니기 힘든 유니크한 값인 `ObjectID`가 생성
  - 기본키로 유닉스 시간 기반의 타임스탬프(4바이트), 랜덤 값(5바이트), 카운터(3바이트)로 이루어짐

1. redis

**인메모리** 데이터베이스이자 **키-값 데이터 모델 기반**의 데이터베이스

- 기본적인 데이터 타입 : 문자열(string)
- 최대 512MB까지 저장
- 이 외에도 셋(set), 해시(hash) 등 지원
- pub/sub 기능을 통해 채팅 시스템, 다른 데이터베이스 앞단에 두어 사용하는 캐싱 계층, 단순한 키-값이 필요한 세션 정보 관리, 정렬된 셋(sorted set) 자료 구조를 이용한 실시한 순위표 서비스에 사용

# 4.5 인덱스

## 4.5.1 인덱스의 필요성

- 인덱스: 데이터를 빠르게 찾을 수 있는 하나의 장치

## 4.5.2 B-트리

인덱스는 보통 B-트리라는 자료 구조로 이루어져 있음

- 이는 **루트 노드**, **리프 노드**, 루트 노드와 리프 노드 사이의 **브랜치 노드**로 나뉨

- 인덱스가 효율적인 이유
  효율적인 단계를 거쳐 모든 요소에 접근할 수 있는 **균형 잡인 트리 구조**와 **트리 깊이의 대수확장성** 때문

❓ 대수확장성: 트리 깊이가 리프 노드 수에 비해 매우 느리게 성장하는 것을 의미

## 4.5.3 인덱스 만드는 방법

1. MySQL

   클러스터형 인덱스 와 세컨더리 인덱스 로 나뉨

   - **클러스터형 인덱스** : 레코드들의 물리적인 저장 순서가 인덱스 순서와 동일하게 되도록 구성된 인덱스
   - **세컨더리 인덱스(보조 인덱스)** : 클러스터 인덱스가 아닌 모든 인덱스

2. MongoDB

   도큐먼트를 만들면 자동으로 `ObjectID` 가 형성 -> 해당 키가 기본키로 설정

   - 세컨더리키도 부가적으로 설정해서 기본키와 세컨더리키를 같이 쓰는 **복합 인덱스** 설정 가능

## 4.5.4 인덱스 최적화 기법

**1. 인덱스는 비용이다.**

인덱스는 두 번 탐색하도록 강요한다.

- 인덱스 리스트, 컬렉션 순으로 탐색하기 때문에 관련 읽기 비용이 듦
- 컬렉션이 수정되었을 때 인덱스도 수정되어야 함

따라서 쿼리에 있는 필드에 인덱스를 무작정 다 설정하는 것은 답이 아님

- 컬렉션에서 가져와야 하는 양이 많을수록 인덱스 사용이 비효율적이 됨

**2. 항상 테스팅하라.**

인덱스 최적화 기법은 서비스에서 사용하는 객체의 깊이, 테이블의 양 등에 따라 달라지므로 항상 테스팅 필요

explain() 함수를 통해 인덱스를 만들고 쿼리를 보낸 이후에 테스팅을 하며 걸리는 시간 최소화해야 함

**3. 복합 인덱스는 같음, 정렬, 다중 값, 카디널리티 순이다.**

보통 여러 필드를 기반으로 조회를 할 때 복합 인덱스를 생성하는데, 이 인덱스 생성 순서에 따라 성능이 달라짐

1. 어떠한 값과 같음을 비교하는 == 이나 equal이라는 쿼리가 있다면 제일 먼저 인덱스로 설정
2. 정렬에 쓰는 필드라면 그다음 인덱스로 설정
3. 다중 값을 출력해야 하는 필드, 즉 쿼리 자체가 >이거나 < 등 많은 값을 출력해야 하는 쿼리에 쓰는 필드라면 나중에 인덱스 설정
4. 유니크한 값의 정도 : 카디널리티. 이 카디널리티가 높은 순서를 기반으로 인덱스를 생성해야 한다. 예를 들어 age와 email이 있을 때, email이 더 높다. 즉 email이라는 필드에 대한 인덱스를 먼저 생성해야 함

# 4.6 조인의 종류

조인: 두 개 이상의 테이블을 묶어서 하나의 결과물을 만드는 것

- MySQL : **JOIN** 쿼리
- MongoDB : **lookup** 쿼리

참고로 MongoDB의 lookup 연산은 관계형 데이터베이스 조인 연산보다 성능이 떨어지므로, 여러 테이블을 조인하는 작업이 많을 경우 **관계형 데이터베이스** 사용

**조인의 종류**

1. **내부 조인**: 왼쪽 테이블과 오른쪽 테이블의 두 행이 모두 일치하는 행이 있는 부분만 표기
   - 두 테이블 간에 교집합을 나타냄
2. **왼쪽 조인**: 왼쪽 테이블의 모든 행이 결과 테이블에 표기
   - 오른쪽 테이블에 일치하는 항목이 없으면 해당 값은 null 값이 됨
3. **오른쪽 조인**: 오른쪽 테이블의 모든 행이 결과 테이블에 표기
   - 왼쪽 테이블에 일치하는 항목이 없으면 해당 값은 null 값이 됨
4. **합집합 조인**: 두 개의 테이블을 기반으로 조인 조건에 만족하지 않는 행까지 모두 표기
   - 일치하는 항목이 없으면 **누락된 쪽**에 null 값이 포함되어 출력

# 4.7 조인의 원리

## 4.7.1 중첩 루프 조인

중첩 for 문과 같은 원리로 조건에 맞는 조인을 하는 방법

- 랜덤 접근에 대한 비용이 많이 증가하므로 대용량의 테이블에서는 사용하지 않음

```sql
for each row in t1 matching reference key {
    for each row in t2 matching reference key {
        if row satisfies join conditions, send to client
    }
}
```

중첩 루프 조인에서 발전한 **블록 중첩 루프 조인(BNL, Block Nested Loop)** 방식도 있음

- 조인할 테이블을 작은 블록으로 나눠서 블록 하나씩 조인

## 4.7.2 정렬 병합 조인

각각의 테이블을 **조인할 필드 기준으로 정렬**하고, 정렬이 끝난 이후에 조인 작업을 수행하는 조인

- 조인할 때 쓸 적절한 인덱스가 없을 때
- 대용량의 테이블을 조인할 때
- 조인 조건으로 < , > 등 범위 비교 연산자가 있을 때

## 4.7.3 해시 조인

해시 테이블을 기반으로 조인하는 방법

- 하나의 테이블이 메모리에 온전히 들어간다면 보통 **중첩 루프 조인**보다 더 효율적임
- 동등(=) 조건에서만 사용 가능

MySQL의 해시 조인 단계는 **빌드 단계**, **프로브 단계**로 나뉨

1. 빌드 단계 : 입력 테이블 중 하나를 기반으로 메모리 내 해시 테이블을 빌드하는 단계
   - 바이트가 더 작은 테이블을 기반으로 해서 테이블을 빌드
   - 조인에 사용되는 필드가 **해시 테이블의 키**로 사용됨
2. 프로브 단계: 레코드 읽기를 시작하며, 각 레코드에서 특정 값에 일치하는 레코드를 찾아서 결과값으로 반환하는 단계

이를 통해 각 테이블은 한 번씩만 읽게 되어 중첩해서 두 개의 테이블을 읽는 중첩 루프 조인보다 보통은 성능이 더 좋다.

참고로 사용 가능한 메모리양은 시스템 변수 join_buffer_size 에 의해 제어되며, 런타임 시에 조정할 수 있다.
