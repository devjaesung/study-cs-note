# 5장 자료구조

- 자료구조: 효율적으로 데이터를 관리하고 수정, 삭제, 탐색, 저장할 수 있는 데이터 집합

# 5.1 복잡도

## 5.1.1 시간 복잡도

**C++의 기본**

**빅오 표기법**

- 시간 복잡도
    - 문제를 해결하는 데 걸리는 시간과 입력의 함수 관계
    - 어떤 알고리즘의 로직이 얼마나 오랜 시간이 걸리는지를 나타내는 데 쓰이며 보통 빅오 표기법으로 나타냄.

**시간 복잡도의 존재 이유**

- 효율적인 코드로 개선하는 데 쓰이는 척도가 됨.

## 5.1.2 공간 복잡도

- 공간 복잡도
    - 프로그램을 실행시켰을 때 필요로 하는 자원 공간의 양
    - 정적 변수로 선언된 것 말고도 동적으로 재귀적인 함수로 인해 공간을 계속해서 필요로 할 경우도 포함됨.

## 5.1.3 자료 구조에서의 시간 복잡도

- 보통 시간 복잡도를 생각할 때 평균, 그리고 최악의 시간 복잡도를 고려하며 씀.

# 5.2 선형 자료 구조

- 일렬로 나열되어 있는 자료 구조

## 5.2.1 연결 리스트

- 데이터를 감싼 노드를 포인터로 연결해서 공간적인 효율성을 극대화시킨 자료 구조
- 삽입과 삭제가 O(1)이 걸리며 탐색에는 O(n)이 걸림

**연결 리스트**

- 싱글 연결 리스트: next 포인터만 가짐
- 이중 연결 리스트: next 포인터와 prev 포인터를 가짐
- 원형 이중 연결 리스트: 이중 연결 리스트와 같지만 마지막 노드의 next 포인터가 헤드 노드를 가리키는 것을 말함

이중 연결 리스트의 종류 

- push_front(): 앞에서부터 요소를 넣음
- push_back(): 뒤에서부터 요소를 넣음
- insert(): 중간에 요소를 넣음

## 5.2.2 배열

- 같은 타입의 변수들로 이뤄져있고, 크기가 정해져 있으며, 인접한 메모리 위치에 있는 데이터를 모아놓은 집합
- 중복을 허용하고 순서가 존재

정적 배열을 기준으로 설명

- 탐색에 O(1)이 되어 랜덤 접근이 가능함
- 삽입과 삭제에는 O(n)이 걸림

따라서 데이터 추가와 삭제를 많이 하는 것은 연결 리스트, 탐색을 많이 하는 것은 배열로 하는 게 베스트

**랜덤 접근과 순차적 접근**

- 랜덤 접근(직접 접근): 동일한 시간에 배열과 같은 순차적인 데이터가 있을 때 임의의 인덱스에 해당하는 데이터에 접근할 수 있는 기능
- 순차적 접근: 데이터를 저장된 순서대로 검색해야 함

**배열과 연결 리스트 비교**

- 배열: 상자를 순서대로 나열한 데이터 구죠
- 몇 번 째 상자인지만 알면 해당 상자의 요소를 끄집어 낼 수 있음
- 연결 리스트: 상자를 선으로 연결한 형태의 데이터 구조.
- 상자 안의 요소를 알기 위해서는 하나씩 상자 내부를 확인해 봐야함

따라서 탐색은 배열이 빠르고 데이터 추가 및 삭제는 연결 리스트가 빠름

## 5.2.3 벡터

- 동적으로 요소를 할당할 수 있는 동적 배열
- 컴파일 시점에 개수를 모른다면 벡터를 써야 함
- 중복을 허용하고 순서가 있고 랜덤 접근이 가능함
- 탐색은 맨 뒤의 요소를 삭제하거나 삽입하는 데 O(1)이 걸리며
- 맨 뒤나 맨 앞이 아닌 요소의 삭제와 삽입하는 데 O(n)의 시간이 걸림

## 5.2.4 스택

- 가장 마지막으로 들어간 데이터가 가장 첫 번째로 나오는 성질을 가진 자료구조 (LIFO, Last In Fast Out)
- 재귀적인 함수, 알고리즘에 사용되며 웹 브라우저 방문 기록 등에 사용됨
- 삽입 및 삭제에 O(1), 탐색에 O(n)이 걸림

## 5.2.5 큐

- 먼저 집어넣은 데이터가 먼저 나오는 성질을 지닌 자료구조 (FIFO,First-In-First-Out)
- 삽입 및 삭제에 O(1), 탐색에 O(n)이 걸림
- CPU 작업을 기다리는 프로세스, 스레드 행렬 또는 네트워크 접속을 기다리는 행렬, 너비 우선 탐색, 캐시 등에 사용됨

# 5.3 비선형 자료 구조

- 일렬로 나열하지 않고 자료 순서나 관계가 복잡한 구조
- 일반적으로 트리나 그래프를 말함

## 5.3.1 그래프

- 정점과 간선으로 이뤄진 자료 구조
    - 단방향 간선
    - 양방향 간선
- 가중치: 간선과 정점 사이에 드는 비용.

## 5.3.2 트리

- 그래프 중 하나로 그래프의 특징처럼 정점과 간선으로 이뤄져 있고, 트리 구조로 배열된 일종의 계층적 데이터의 집합
- 루트 노드, 내부 노드, 리프 노드 등으로 구성됨
- 트리로 이뤄진 집합을 숲이라고 함

**이진 트리**

- 자식 노드가 2개 이하인 트리
    - 정이진 트리, Full Binary Tree: 자식 노드가 0개 또는 2개
    - 완전 이진 트리, Complete Binary Tree: 왼쪽에서부터 채워져 있는 이진 트리
    - 변질 이진 트리, Degenerate Binary Tree: 자식 노드가 1개
    - 포화 이진 트리, Perfect Binary Tree: 모든 노드가 꽉 차 있는 이진 트리
    - 균형 이진 트리, Balanced Binary Tree: 왼쪽 노드와 오른쪽 노드의 높이 차이가 1 이하인 이진 트리.

**이진 탐색 트리**

- 노드의 오른쪽 하위 트리에는 노드 값 보다 큰 값이 있는 노드만 포함되고, 왼쪽 하위 트리에는 ‘노드 값보다 작은 값’이 들어 있는 트리
- 검색에 용이
- 삽입 순서에 따라 선형적일 수 있기 때문에 보통 O(logn)이 걸림. 하지만 최악의 경우 O(n)이 걸림

**AVL 트리**

- 이진 탐색 트리는 선형적인 트리 형태를 가질 때 최악의 경우 O(n)의 시간 복잡도를 가짐.
- 이러한 최악의 경우를 배제하고 항상 균형 잡힌 트리로 만들자 라는 개념을 가진 트리가 AVL 트리임
- 탐색, 삽입, 삭제 모두 시간 복잡도가 O(logn)
- 삽입, 삭제 시 균형이 안 맞는 것을 맞추기 위해 트리 일부를 왼쪽 혹은 오른쪽으로 회전시키며 균형을 잡음

**레드 블랙 트리**

- 균형 이진 탐색 트리로 탐색, 삽입, 삭제 모두 시간 복잡도가 O(logn)임
- 각 노드는 빨간색 또는 검은 색의 색상을 나타내는 추가 비트를 저장하며, 삽입 및 삭제 중에 트리가 균형을 유지하도록 하는 데 사용됨

## 5.3.3 힙

- 완전 이진 트리 기반의 자료 구조.
    - **최대 힙**: 루트 노드에 있는 키는 모든 자식에 있는 키 중에서 가장 커야 함. 또한 각 노드의 자식 노드와의 관계도 이와같은 특징이 재귀적으로 이뤄져야 함
    - **최소 힙**: 최소힙에서 루트 노드에 있는 키는 모든 자식에 있는 키 중에서 최솟값이어야 함. 또한 각 노드의 자식 노드와의 관계도 이와 같은 특징이 재귀적으로 이뤄져야 함

**최대힙의 삽입**

- 힙에 새로운 요소가 들어오면, 일단 새로운 노드를 힙의 마지막 노드에 이어서 삽입.
- 이 새로운 노드를 부모 노드들과의 크기를 비교하여 교환해서 힙의 성질을 만족시킴

**최대힙의 삭제**

- 최대힙에서 최댓값은 루트 노드이므로 루트 노드가 삭제되고, 이후 마지막 노드와 루트 노드를 스왑하여 또 다시 스왑 등의 과정을 거쳐 재구성 됨

## 5.3.4 우선순위 큐

- 우선순위 대기열이라고도 함.
- 대기열에서 우선순위가 높은 요소가 우선순위가 낮은 요소보다 먼저 제공되는 자료 구조
- 힙을 기반으로 구현됨

## 5.3.5 맵

- 특정 순서에 따라 키와 매핑된 값의 조합으로 형성된 자료 구조
- "알고리즘": 1, "운영체제": 2 와 같이 string: int 형태로 값을 할당해야 할 때
- 레드 블랙 트리 자료 구조를 기반으로 형성되고, 삽입되면 자동으로 정렬 됨
- 정렬을 보장하지 않는 unordered_map과 정렬을 보장하는 map 두 가지가 있음

## 5.3.6 셋

- 특정 순서에 따라 고유한 요소를 저장하는 컨테이너
- 중복되는 요소는 없고 오로지 unique한 값만 저장하는 자료구조

## 5.3.7 해시 테이블

- 무한에 가까운 데이터들을 유한한 개수의 해시 값으로 매핑한 테이블
- 삽입, 삭제, 탐색 시 평균적으로 **O(1)**의 시간 복잡도를 가지며 unordered_map으로 구현함
